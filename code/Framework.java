package BnP_Framework;
import java.util.*;

/*
This is the program entry, the initial solution is generated by visiting each customer once
The exploration follows Breadth First Search, which means we optimize the root node, and 2 nodes in depth 1, and...
Everytime an integer solution is found, we print it in the console, you can also comment it if you don't want to see it
 */
public class Framework {
    public static void main(String[] args){
        UserParam user = new UserParam("vrp_bp_30.json");
        //  initialize routes, we set each node has a unique routes, which is {0,i} for each customer i
        List<Route> initRoutes = new ArrayList<Route>();
        //UserParam.capacity = 500;
        for (int i = 1; i< UserParam.nodeCount; i++){
             initRoutes.add(new Route(Arrays.asList(0, i)));
        }
        List<BnbNode> unexplored = new ArrayList<BnbNode>();
        List<BnbNode> branchTree = new ArrayList<BnbNode>();
        unexplored.add(new BnbNode(UserParam.arcs, initRoutes));
        int times = 0;
        long startTime = System.currentTimeMillis();
        while (unexplored.size() > 0){
            BnbNode currentNode = unexplored.get(0); //exploring node
            currentNode.columnGeneration();
//            check if the model is feasible
            if(currentNode.feasible) {
//                check if integer condition is satisfied
                if (currentNode.fractionArc.size() == 0) {
                    System.out.println("Integer solution found: " + currentNode.objVal +
                            ", current best solution: " + user.upperBound);
                    //  update the upperbound
                    if (currentNode.objVal < user.upperBound) {
                        user.upperBound = currentNode.objVal;
                        user.bestRoutes = currentNode.solutionRoutes;
                    }
                } else {
//                    check if the solution is valuable(obj < upperbound)
                    if (currentNode.objVal <= user.upperBound) {
//                        start branching
//                        find a fraction arc that the closest to 0.5
                        List<Integer> branchArc = new ArrayList<>();
                        double m = 1.0;
                        for (List<Integer> arc : currentNode.fractionArc.keySet()) {
                            if (Math.abs(currentNode.fractionArc.get(arc) - 0.5) < m) {
                                branchArc = arc;
                                m = Math.abs(currentNode.fractionArc.get(arc) - 0.5);
                            }
                        }
//                        new branch, enforce the visit of branchArc
//                        cut the route that not contains this arc
                        List<Route> branchRoute1 = new ArrayList<>();
                        for (Route p : currentNode.routes) {
//                            return true means the route has to be deleted
                            if (!p.notContainsArc(branchArc)) {
                                branchRoute1.add(p);
                            }
                        }
//                        cut the arcs that not contains this arc
                        List<List<Integer>> branchChildArc1 = new ArrayList<>();
                        for (List<Integer> p : currentNode.arcs) {
                            if (!Objects.equals(p.get(0), branchArc.get(0))) {
                                if (!Objects.equals(p.get(1), branchArc.get(1))) {
//                                    both the start and end node are different
                                    branchChildArc1.add(p);
                                }
                            } else if (Objects.equals(p.get(1), branchArc.get(1))) {
                                branchChildArc1.add(p);
                            }
                        }
                        BnbNode enforceVisit = new BnbNode(branchChildArc1, branchRoute1, currentNode);
                        unexplored.add(enforceVisit);
                        currentNode.child.add(enforceVisit);
//                        new branch, enforcing not visiting the arc
                        List<Route> branchRoute2 = new ArrayList<>();
                        for (Route p : currentNode.routes) {
                            // return true means the route has to be deleted
                            if (!p.containsArc(branchArc)) {
                                branchRoute2.add(p);
                            }
                        }
                        List<List<Integer>> branchChildArc2 = new ArrayList<>();
                        for (List<Integer> p : currentNode.arcs) {
                            if (!p.equals(branchArc)) {
                                branchChildArc2.add(p);
                            }
                        }
                        BnbNode enforceNotVisit = new BnbNode(branchChildArc2, branchRoute2, currentNode);
                        unexplored.add(enforceNotVisit);
                        currentNode.child.add(enforceNotVisit);
                    }
                }
            }
            unexplored.remove(0);
//            you can comment the code of the next line to save memory
            //branchTree.add(currentNode);
            times++;
        }
        long endTime = System.currentTimeMillis();
        System.out.println("runtime(s): "+String.format("%.2f", (endTime-startTime)/1000d));
        System.out.println("the best route is: "+user.bestRoutes+ "\nuppder bound: "+user.upperBound);
        System.out.println("number of nodes explored: "+times);
    }
}
